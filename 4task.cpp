#include <iostream>
#include <cmath>
#include <vector>
#include <functional>
#include <iomanip>

#define M_PI 3.14159265358979323846

//=============================================================================
// 1. Узлы и веса Гаусса-Лежандра (64 точки)
//    Можно взять таблицу из справочников/готовых реализаций
//    или сгенерировать программно (например, с помощью алгоритма Голуба-Велча).
//    Ниже статический вариант для интегрирования на отрезке [-1,1].
//=============================================================================
static const int NGL = 64; // количество узлов
// Узлы (x_i) и веса (w_i) для n=64
// Источник (одно из популярных готовых): 
// https://pomax.github.io/bezierinfo/legendre-gauss.html
static double x64[64] = {
    -0.9993050417357722, -0.9963401167719553, -0.9910133714767443, 
    -0.9833362538846259, -0.9733268277899109, -0.9610087996520538, 
    -0.9464113748584028, -0.9295691721319396, -0.9105221370785028, 
    -0.8893154459951141, -0.8659993981540928, -0.8406292962525803, 
    -0.8132653151227975, -0.7839723589433414, -0.7528199072605319, 
    -0.7198818501716109, -0.6852363130542333, -0.6489654712546573, 
    -0.6111553551723933, -0.5718956462026340, -0.5312794640198946, 
    -0.4894031457070529, -0.4463660172534641, -0.4022701579639916, 
    -0.3572201583376681, -0.3112201915168279, -0.2642760443342740, 
    -0.2163942146271470, -0.1675811823501360, -0.1178445152985335, 
    -0.06720132485111360, -0.01657824114697868,  0.01657824114697868, 
     0.06720132485111360,  0.1178445152985335,  0.1675811823501360, 
     0.2163942146271470,  0.2642760443342740,  0.3112201915168279, 
     0.3572201583376681,  0.4022701579639916,  0.4463660172534641, 
     0.4894031457070529,  0.5312794640198946,  0.5718956462026340, 
     0.6111553551723933,  0.6489654712546573,  0.6852363130542333, 
     0.7198818501716109,  0.7528199072605319,  0.7839723589433414, 
     0.8132653151227975,  0.8406292962525803,  0.8659993981540928, 
     0.8893154459951141,  0.9105221370785028,  0.9295691721319396, 
     0.9464113748584028,  0.9610087996520538,  0.9733268277899109, 
     0.9833362538846259,  0.9910133714767443,  0.9963401167719553, 
     0.9993050417357722
};
static double w64[64] = {
    0.00178328072169643, 0.00414703326056247, 0.00650445796897836, 
    0.00884675982636395, 0.0111681394601311,  0.0134630478967186, 
    0.0157260304760247,  0.0179517157756973,  0.0201348231535302, 
    0.0222701738083833,  0.0243527025687109,  0.0263774697150547, 
    0.0283396726142595,  0.0302346570724025,  0.0320579283548516, 
    0.0338051618371416,  0.0354722132568824,  0.0370551285402400, 
    0.0385501531786156,  0.0399537411327203,  0.0412625632426235, 
    0.0424735151236536,  0.0435837245293235,  0.0445915578235289, 
    0.0454945672346140,  0.0462906313514677,  0.0469777945358916, 
    0.0475552911471748,  0.0480226282409613,  0.0483794750525971, 
    0.0486257611278599,  0.0487616956877830,  0.0487877896056176, 
    0.0487048716676428,  0.0485139487130197,  0.0482162666386124, 
    0.0478134172291650,  0.0473062773417447,  0.0466960152007298, 
    0.0459841389398090,  0.0451724020451060,  0.0442626851578201, 
    0.0432570607793287,  0.0421577315419870,  0.0409670380498051, 
    0.0396873833838090,  0.0383212413098172,  0.0368711663507064, 
    0.0353398110657880,  0.0337299221772892,  0.0320443736112056, 
    0.0302861928909020,  0.0284584901278450,  0.0265644360036460, 
    0.0246073486325235,  0.0225905672306623,  0.0205174998930320, 
    0.0183915441615654,  0.0162161901084652,  0.0139949863478453, 
    0.0117315116069389,  0.00942943378911320, 0.00709243208979561, 
    0.00472455881381301
};

//=============================================================================
// 2. Функция для взвешенного интегрирования на отрезке [a,b] методом 
//    Гаусса-Лежандра с 64 точками.
//    Вычисляет  int_a^b f(x) dx .
//=============================================================================
double gaussLegendre64(std::function<double(double)> f, double a, double b) 
{
    double c1 = 0.5 * (b - a);
    double c2 = 0.5 * (b + a);
    double sum = 0.0;
    for(int i = 0; i < NGL; i++) {
        // Сдвиг и масштабирование узла с [-1,1] в [a,b]
        double x = c1 * x64[i] + c2;
        sum += w64[i] * f(x);
    }
    return c1 * sum; 
}

//=============================================================================
// 3. Интеграл I_a = \int_0^1 sin(\pi x^5) / [ x^5 (1 - x) ] dx
//    Достаточно использовать gaussLegendre64 на отрезке [0,1].
//=============================================================================
double integrandA(double x)
{
    // Осторожно с x=0 или x=1. Но как обсуждалось:
    //   sin(pi*x^5)/(x^5) ~ pi  при x->0,
    //   а при x->1   sin(pi*1)=0 => особенность (1-x) "убивается" нулём в числителе
    // Так что "реальной" сингулярности нет.
    // Однако, чтобы избежать деления на крошечный x^5, можно анализировать,
    // но здесь прямо:
    if (x == 0.0) {
        // Лимит = pi / (1 - 0) = pi
        return M_PI;
    }
    if (x == 1.0) {
        // Лимит = 0, потому что sin(pi*1^5) = 0
        return 0.0;
    }
    return std::sin(M_PI * std::pow(x, 5)) / (std::pow(x, 5) * (1.0 - x));
}

//=============================================================================
// 4. Интеграл I_b = \int_0^\infty exp(- sqrt(x) * sin(x/10)) dx
//    Применим замену x = t/(1 - t), t in [0,1).
//    dx = 1/(1 - t)^2 dt
//    => I_b = \int_0^1 e^{- sqrt(t/(1-t)) * sin( [t/(1-t)] /10 )} * 1/(1-t)^2 dt
//=============================================================================
double integrandB_subst(double t)
{
    if (t == 1.0) {
        // При t->1 => x->∞, экспонента обычно уходит в 0, 
        // но проверим аккуратно. sin(...) может колебаться.
        // В любом случае сама формула dx/dt = 1/(1-t)^2 становится большой.
        // Пусть вернёт 0.0 для t=1 точно. 
        return 0.0;
    }
    // x = t/(1 - t)
    double x = t / (1.0 - t);
    double val = std::exp( - std::sqrt(x) * std::sin( x / 10.0 ) );
    double dxdT = 1.0 / std::pow(1.0 - t, 2);
    return val * dxdT;
}

//=============================================================================
// Главная программа
//=============================================================================
int main()
{
    std::cout << std::fixed << std::setprecision(12);

    //--------------------------------------------------------------------------
    // 1) Интеграл I_a на [0,1]
    //--------------------------------------------------------------------------
    auto I_a = gaussLegendre64(integrandA, 0.0, 1.0);

    //--------------------------------------------------------------------------
    // 2) Интеграл I_b на [0,∞)
    //    Делается замена x = t/(1 - t), тогда t in [0,1).
    //--------------------------------------------------------------------------
    auto I_b = gaussLegendre64(integrandB_subst, 0.0, 1.0);

    std::cout << "I_a = " << I_a << "\n";
    std::cout << "I_b = " << I_b << "\n";

    return 0;
}
